#pragma once
#include <stdlib.h>

#ifdef _WIN32
#include <WinSock2.h>
#include <process.h>
#ifdef _UNICODE
#include <comdef.h>
#endif
typedef int socklen_t;
typedef void RET_TYPE;
#else
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
typedef unsigned int SOCKET;
#define INVALID_SOCKET  (SOCKET)(~0)
#define SOCKET_ERROR            (-1)
#ifndef _T
#define _T(x) x
#endif
typedef struct in_addr IN_ADDR;
typedef unsigned long       DWORD;
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef float               FLOAT;
typedef FLOAT               *PFLOAT;
typedef BOOL            *PBOOL;
typedef BOOL             *LPBOOL;
typedef BYTE            *PBYTE;
typedef BYTE             *LPBYTE;
typedef int             *PINT;
typedef int              *LPINT;
typedef WORD            *PWORD;
typedef WORD             *LPWORD;
typedef long             *LPLONG;
typedef DWORD           *PDWORD;
typedef DWORD            *LPDWORD;
typedef void             *LPVOID;

typedef int                 INT;
typedef unsigned int        UINT;
typedef unsigned int        *PUINT;
typedef const char* LPCTSTR, *LPCSTR;
typedef char* LPTSTR, *LPSTR;
typedef void* RET_TYPE;
inline int GetLastError()
{
	return errno;
}
#define closesocket(x) close(x)


#ifndef FALSE
#define FALSE               0
#endif

#ifndef TRUE
#define TRUE                1
#endif
#endif

//该类用于控制台开发
class CPhdSocket
{
private:
	SOCKET m_hSocket;//核心成员变量

public:
	CPhdSocket();
	virtual ~CPhdSocket();

	operator SOCKET() const
	{
		return m_hSocket;
	}

	//关闭socket
	void Close();

	// Summary:   该对象是否为空
	// Time:	  2020年3月31日 peihaodong
	// Explain:	  
	bool IsNull() const;

	//创建socket并绑定
	//nSocketPort - 端口；如果是0，绑定随机端口
	//lpszSocketAddress - IP地址
	BOOL Create(UINT nSocketPort = 0, int nSocketType = SOCK_STREAM
		, LPCTSTR lpszSocketAddress = NULL);

	// Summary:   侦听
	// Time:	  2020年3月30日 peihaodong
	// Explain:	  nConnectionBacklog - 代表同时能连接5个客户端，超过5个需要等待
	BOOL Listen(int nConnectionBacklog = 5);

	// Summary:   接收（阻塞操作，有客户端连接会生成新的SocketPhd对象）
	// Time:	  2020年3月30日 peihaodong
	// Explain:	  返回SocketPhd对象的IP和端口
	BOOL Accept(CPhdSocket& rConnectedSocket, LPTSTR szIP = NULL, 
		UINT *nPort = NULL);

	// Summary:   连接服务器（通过服务器前台IP和端口）
	// Time:	  2020年3月30日 peihaodong
	// Explain:	  
	BOOL Connect(LPCTSTR lpszHostAddress, UINT nHostPort);

	// Summary:   发送数据 向该地址结构体 
	// Time:	  2020年3月30日 peihaodong
	// Explain:	  
	int SendTo(const void* lpBuf, int nBufLen, UINT nHostPort,
		LPCTSTR lpszHostAddress = NULL);

	// Summary:   接收数据 得到发送端的IP和端口
	// Time:	  2020年3月30日 peihaodong
	// Explain:	  
	int ReceiveFrom(void* lpBuf, int nBufLen,
		LPTSTR rSocketAddress, UINT& rSocketPort);

	// Summary:   发送数据，向连接的socket
	// Time:	  2020年3月30日 peihaodong
	// Explain:	  
	int Send(const void* lpBuf, int nBufLen, int nFlags = 0);

	// Summary:   接收数据，向连接的socket
	// Time:	  2020年3月30日 peihaodong
	// Explain:	  
	int Receive(void* lpBuf, int nBufLen, int nFlags = 0);
	
	// Summary:   得到socket信息
	// Time:	  2020年3月30日 peihaodong
	// Explain:	  
	BOOL GetPeerName(LPTSTR rSocketAddress, UINT& rSocketPort);
	BOOL GetSockName(LPTSTR rSocketAddress, UINT& rSocketPort);

};

